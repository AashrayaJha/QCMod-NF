AttachSpec("QCMod.spec");
AttachSpec("coleman.spec");
import "applications.m": Qp_points;
import "singleintegrals.m": is_bad, xy_coordinates;
import "misc.m": function_field;
load "hodge_snip.m";


function inf_deg(Q_trans)
  d:=Degree(Q_trans);
  K := BaseRing(BaseRing(Q_trans));
  // find the points at infinity:
  Kx := RationalFunctionField(K);
  Kxy := PolynomialRing(Kx);
  FF := function_field(Q_trans); // function field of curve over K
  infplaces:=InfinitePlaces(FF);
  infplacesKinf := infplaces;
//     "a,b = ", a,b;
  "inf places", infplacesKinf;
  Kinf := K;
  for Kinf_new in infplacesKinf do
    if not IsOne(Degree(Kinf_new)) then
      // field generated by points at infinity
      //time norm_clos := NormalClosure(AbsoluteField(ResidueClassField(Kinf_new)));
      //time Kinf := Compositum(Kinf, norm_clos);
    finf := CharacteristicPolynomial(ResidueClassField(Kinf_new).1);
      time split := SplittingField(finf);
      time Kinf := Compositum(Kinf, split);
    end if;
  end for;
  dinf := AbsoluteDegree(Kinf);
  "degree of Kinf", dinf; 
  return dinf, split, finf;
end function;


function transform(Q, A)
  
  // Apply the projective transformation given by the 2x2 matrix A to the 
  // curve defined by Q(x,y)=0. A acts on X and Z, but not Y.
  y := Parent(Q).1;
  x := BaseRing(Parent(Q)).1;
  K := BaseRing(BaseRing(Q));
  PK3<X,Y,Z>:=PolynomialRing(K,3);
  Q_dehom:=PK3!0;
  d := Degree(Q);
  for i:=0 to d do
    for j:=0 to Degree(Coefficient(Q,i)) do
      Q_dehom +:= Coefficient(Coefficient(Q,i),j)*Y^i*X^j;
    end for;
  end for;
  //We should probably have A^(-1), since det(A) is not always 1
  transformed_vars := [A[2,2]*X-A[1,2]*Z,Y,-A[2,1]*X+A[1,1]*Z];
  Q_hom := Homogenization(Q_dehom, Z);
  Q_trans_hom:=Evaluate(Q_hom, transformed_vars);
  Q_trans_dehom := Evaluate(Q_trans_hom, [X,Y,1]);
  Q_trans := Parent(Q)!0;
  for i:=0 to Degree(Q_trans_dehom, Y) do
    for j:=0 to Degree(Q_trans_dehom, Y)  do
      Q_trans +:= K!Coefficient(Coefficient(Q_trans_dehom, Y,i), X, j)*x^j*y^i;
    end for;
  end for;

  return Q_trans;
end function;

function good_transform(Q, A, embeddings : N := 6, empty := [1,2])
  // check if the transformation given by the 2x2 matrix A yields an
  // affine patch without bad residue disks with respect to the ith
  // embedding of F into Qp, where i runs through empty. 
  // Note that A acts on X and Z, but not Y.
  v1,v2 := Explode(embeddings);
  Q_trans := transform(Q, A);
  try 
    new_data1 := ColemanData(Q_trans, v1, N);
  catch e;
    e;
    return false, _, _, _, _, _;
  end try;
  new_Qppoints_1 := Qp_points(new_data1 : Nfactor := 1.5);
pts1 := [xy_coordinates(P, new_data1):P in new_Qppoints_1 | not is_bad(P, new_data1)];
  good1 := &and[not(is_bad(P, new_data1)) : P in new_Qppoints_1];
  if 1 notin empty or good1 then 
    try 
      new_data2 := ColemanData(Q_trans, v2, N : useU:=false);
    catch e;
      e;
      return false, _, _, _, _, _;
    end try;
    new_Qppoints_2 := Qp_points(new_data2 : Nfactor := 1.5);
    good2 := &and[not(is_bad(P, new_data2)) : P in new_Qppoints_2];
    if 2 notin empty or good2 then
      return true, Q_trans, new_data1, new_data2, new_Qppoints_1, new_Qppoints_2;
    end if;
  end if;
  return false, _, _, _, _, _;
end function;



function good_patches_modp(data1, data2, p : empty := [1,2], N := 6) 
  Q := data1`Q;
  v1 := data1`v;
  v2 := data2`v;
  F := BaseRing(BaseRing(Q));
  u := F.1;
  Qp1, sigma1 := Completion(F, v1);
  Qp2, sigma2 := Completion(F, v2);
  Fp := GF(p);
  Qppoints1 := Qp_points(data1);
  Qppoints2 := Qp_points(data2);
  xs1 := [xy_coordinates(pt, data1)[1] : pt in Qppoints1 | not pt`inf];
  xs2 := [xy_coordinates(pt, data2)[1] : pt in Qppoints2 | not pt`inf];
  sigmas := [sigma1, sigma2];
  xs := [xs1, xs2];
  good_coeffs_modp := [];
  for a,b in [0..p-1] do
    if &and[Fp!sigmas[i](a+b*F.1) notin xs[i] : i in empty] then
      "trying a+b*u", a+b*u;
      A := [[1,1], [1,-(a+b*u)]];
      bool, Q_trans, new_data1, new_data2, new_Qppoints_1, new_Qppoints_2 := good_transform(Q, A, [v1,v2] : empty := empty);
      "bool", bool;
      if bool then
        C2 := CurveFromBivariate(Q_trans);
        //DO1 := DixmierOhnoInvariants(C1);
        //DO2 := DixmierOhnoInvariants(C2);
        //assert DixmierOhnoInvariantsEqual(DO1, DO2);
        // The above works, but only checks isomorphism over \bar{K}
        C1 := CurveFromBivariate(Q);
        assert IsIsomorphicPlaneQuartics(C1,C2);
        infdeg, split := inf_deg(Q_trans);
        "works!", [a,b];
        Append(~good_coeffs_modp, [a,b,infdeg]);
      end if;
    end if;
  end for;
  return good_coeffs_modp;
end function;



K<zeta3> := CyclotomicField(3);
Q := Polynomial([PolynomialRing(CyclotomicField(3)) | [[ RationalField() | 1, 1 ], [ RationalField() | 1, -1 ], [ RationalField() | 0, 3 ], [ RationalField() | 0, -1 ]], [[ RationalField() | 0, -2 ], [ RationalField() | 0, 3 ], [ RationalField() | 0, -3 ], [ RationalField() | 2, 2 ]], [[ RationalField() | -3, 0 ]], [[ RationalField() | 2, 3 ], [ RationalField() | -1, 1 ]], [[ RationalField() | 1, 0 ]]]);
v1 := ideal<Integers(CyclotomicField(3)) | \[ 13, 0 ], \[ 4, 1 ]>;
v2 := ideal<Integers(CyclotomicField(3)) | \[ 13, 0 ], \[ 10, 1 ]>;
p := 13;
data1 := ColemanData(Q, v1, 6);
data2 := ColemanData(Q, v2, 6);
/*
good_modp := good_patches_modp(data1, data2, 13 : empty := [1], N := 8);
// One gets this A by noticing that under both embeddings there is no 
// Q13-point with x-coordinate 11 on the curve defined by Q=0, and that 
// the only bad disks are at infinity.
*/
N := 6;
Patches := [];
good_modp := [ [ 0, 12 ], [ 3, 11 ], [ 5, 10 ], [ 7, 4 ], [ 8, 1 ], [ 8, 9 ], [ 10, 3 ], [ 11, 0 ] ];

pair := good_modp[1];
//for pair in good_modp do
  //"trying a,b=", pair;
//  for i,j in [0..0] do
i:=0;j:=0;
    a := i*p+pair[1];
    b := j*p+pair[2];
    A := [[1,1], [1,-(a+b*u)]];
    Q_trans := transform(Q, A);
    bool, Q_trans, new_data1, new_data2, new_Qppoints_1, new_Qppoints_2 := good_transform(Q, A, [v1,v2] : N := 6, empty := [1,2]);
//    if bool then
    Q := Q_trans;
data1 := new_data1;
  d:=Degree(Q_trans);
  h1basis, g, r, W0 := H1Basis(Q, v1); 
  standard_sympl_mat := ZeroMatrix(K,2*g,2*g);
  for i in [1..g] do
    standard_sympl_mat[i,g+i] := 1; standard_sympl_mat[g+i,i] := -1;
  end for;

  vprint QCMod, 3: " Computing the cup product matrix";
  cpm_prec := 2*g;
  if assigned cpm then delete cpm; end if;
  repeat 
    try 
      //cpm := CupProductMatrix(h1basis, Q, g, r, W0 : prec := cpm_prec);
      // If this takes very long, try 
       cpm := CupProductMatrix(h1basis, Q, g, r, W0 : prec := cpm_prec, split := false);
    catch e;
      cpm_prec +:= g;
    end try;
  until assigned cpm;
  if cpm ne standard_sympl_mat then 
    coefficients := SymplecticBasisH1(cpm); // Create coefficients of a symplectic basis in terms of h1basis
    new_complementary_basis := [&+[coefficients[i,j]*h1basis[j] : j in [1..2*g]] : i in [1..g]];
    sympl_basis := [h1basis[i] : i in [1..g]] cat new_complementary_basis;
    if not &and[&and[Valuation(c, v1) ge 0 : c in Coefficients(w[1])] : w in sympl_basis] then
      error "The computed symplectic basis is not integral. Please try a different prime or a different basis.";
    end if; 
    if not &and[&and[Valuation(c, v2) ge 0 : c in Coefficients(w[1])] : w in sympl_basis] then
      error "The computed symplectic basis is not integral. Please try a different prime or a different basis.";
    end if;
    vprintf QCMod, 3: " Symplectic basis of H^1:\n%o\n", sympl_basis;
    basis0 := [[sympl_basis[i,j] : j in [1..Degree(Q)]] : i in [1..g]]; // basis of regular differentials
    basis1 := [[sympl_basis[i,j] : j in [1..Degree(Q)]] : i in [g+1..2*g]];  // basis of complementary subspace
  end if;
  if Type(data1) eq RngIntElt then 
    data1 := ColemanData(Q, v1, N : useY:=true,  basis0:=basis0, basis1:=basis1, basis2:=[]);
  end  if;


      // find the points at infinity:

      Kx := RationalFunctionField(K);
      Kxy := PolynomialRing(Kx);

      FF := function_field(Q_trans); // function field of curve over K
      Q := Q_trans;
      dinf, split, finf := inf_deg(Q);
rts_tuples := Roots(finfsplit);
rts := [t[1] : t in rts_tuples];
subfields := [ ]; 
infplacesext := [ ];
Kinfs := [];
for rt in rts do
  subfield, embedding := sub<split | rt>;
  Append(~subfields, <subfield, embedding>);
  Kinf := subfields[1,1];
  Kinfx:=RationalFunctionField(Kinf);
  Kinfxy:=PolynomialRing(Kinfx);
  FFKinf:=FunctionField(Kinfxy!Q);
  time infplacesKinf:=InfinitePlaces(FFKinf); // places at infinity 
deg1_places := [P : P in infplacesKinf | Degree(P) eq 1];
assert #deg1_places eq 1;
Append(~infplacesext, deg1_places[1]); 
end for;

      infplaces:=InfinitePlaces(FF);
      //infplacesKinf := infplaces;
      //"a,b = ", a,b;
      //"inf places", infplacesKinf;

      //Kinf := K;
      /*
      for Kinf_new in infplacesKinf do
        if not IsOne(Degree(Kinf_new)) then
          // field generated by points at infinity
          //time norm_clos := NormalClosure(AbsoluteField(ResidueClassField(Kinf_new)));
          //time Kinf := Compositum(Kinf, norm_clos);
        time f := CharacteristicPolynomial(ResidueClassField(Kinf_new).1);
          time split := SplittingField(f);
          galois := GaloisGroup(CharacteristicPolynomial(ResidueClassField(Kinf_new).1));
       //   time Kinf := Compositum(Kinf, split);
        end if;
      end for;
      //dinf := AbsoluteDegree(Kinf); //dinf := Degree(split);
      //"degree of Kinf", dinf; 
      if #galois lt 24 then
        "yay!!!"; a,b,galois,Q_trans;
      end if;
fsplit := ChangeRing(f, split);
      //Append(~Patches, <pair, dinf>); //      <pair, Q_trans>; //      Append(~Patches, <pair, Q_trans>);
//    end if;
    */
//  end for;
//end for;
//Qs := [t[2] : t in Patches];
//
//
/*Qxy<x,y> := PolynomialRing(Rationals(), 2);
Qs :=
[
y^4 + ((21*u + 10)*x + (2*u + 3))*y^3 + (-3*x^2 + 6*x - 3)*y^2 + ((-3418*u - 2988)*x^3 + (711*u - 576)*x^2 + (123*u + 180)*x - 10*u - 2)*y + (-1703*u + 445)*x^4 + (1579*u - 1407)*x^3 + (264*u + 1083)*x^2 + (-146*u - 121)*x + 6*u,
y^4 + ((16*u + 12)*x + (2*u + 3))*y^3 + (-3*x^2 + 6*x - 3)*y^2 + ((-683*u - 1924)*x^3 + (738*u + 45)*x^2 + (69*u + 147)*x - 10*u - 2)*y + (-1212*u - 612)*x^4 + (1464*u + 186)*x^3 + (-153*u + 540)*x^2 + (-105*u - 114)*x + 6*u,
y^4 + ((12*u + 13)*x + (2*u + 3))*y^3 + (-3*x^2 + 6*x - 3)*y^2 + ((542*u - 720)*x^3 + (606*u + 330)*x^2 + (30*u + 120)*x - 10*u - 2)*y + (-584*u - 734)*x^4 + (970*u + 642)*x^3 + (-318*u + 198)*x^2 + (-74*u - 106)*x + 6*u,
y^4 + ((-2*u + 9)*x + (2*u + 3))*y^3 + (-3*x^2 + 6*x - 3)*y^2 + ((-170*u + 254)*x^3 + (-150*u + 114)*x^2 + (-54*u + 18)*x - 10*u - 2)*y + (162*u + 144)*x^4 + (-108*u + 48)*x^3 + (-72*u - 144)*x^2 + (12*u - 48)*x + 6*u,
y^4 + ((-9*u + 7)*x + (2*u + 3))*y^3 + (-3*x^2 + 6*x - 3)*y^2 + ((-853*u - 684)*x^3 + (-447*u - 255)*x^2 + (-96*u - 33)*x - 10*u - 2)*y + (-182*u + 133)*x^4 + (-56*u - 69)*x^3 + (177*u - 45)*x^2 + (55*u - 19)*x + 6*u,
y^4 + ((7*u + 15)*x + (2*u + 3))*y^3 + (-3*x^2 + 6*x - 3)*y^2 + ((1171*u + 812)*x^3 + (321*u + 561)*x^2 + (-24*u + 87)*x - 10*u - 2)*y + (258*u - 387)*x^4 + (192*u + 675)*x^3 + (-423*u - 189)*x^2 + (-33*u - 99)*x + 6*u,
y^4 + ((-7*u + 11)*x + (2*u + 3))*y^3 + (-3*x^2 + 6*x - 3)*y^2 + ((-1413*u - 398)*x^3 + (-591*u - 123)*x^2 + (-108*u - 15)*x - 10*u - 2)*y + (-10*u + 491)*x^4 + (-184*u - 231)*x^3 + (135*u - 219)*x^2 + (53*u - 41)*x + 6*u,
y^4 + ((-14*u + 9)*x + (2*u + 3))*y^3 + (-3*x^2 + 6*x - 3)*y^2 + ((-2330*u - 2662)*x^3 + (-966*u - 726)*x^2 + (-150*u - 66)*x - 10*u - 2)*y + (-978*u + 12)*x^4 + (336*u - 36)*x^3 + (540*u + 36)*x^2 + (96*u - 12)*x + 6*u
];


    
 
good_trans_1 := [u+2, 4*u+1, 6*u+9];
good_affines_1 := [];
for a in good_trans_1 do
  A := [[1,1], [1,-a]];
  bool, Q_trans, new_data1, new_data2, new_Qppoints_1, new_Qppoints_2 := good_transform(Q, A, [v1,v2] : N := 6, empty := [1]);
  bool;
  "a", a;
  "Q_trans", Q_trans;
  Append(~good_affines_1, Q_trans);
  infdeg(Q_trans);
end for;
*/
