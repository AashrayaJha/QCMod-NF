//from HodgeData in hodge.m


//import "misc.m": function_field;

function infdeg(Q)

  d:=Degree(Q);
  K := BaseRing(BaseRing(Q));

  // find the points at infinity:

  Kx := RationalFunctionField(K);
  Kxy := PolynomialRing(Kx);

  FF := function_field(Q); // function field of curve over K
  infplaces:=InfinitePlaces(FF);
  infplacesKinf := infplaces;
infplacesKinf;

  Kinf := K;
  repeat 
    for Kinf_new in infplacesKinf do
      if not IsOne(Degree(Kinf_new)) then
        // field generated by points at infinity
        //time norm_clos := NormalClosure(AbsoluteField(ResidueClassField(Kinf_new)));
        //time Kinf := Compositum(Kinf, norm_clos);
        time split := SplittingField(CharacteristicPolynomial(ResidueClassField(Kinf_new).1));
        time Kinf := Compositum(Kinf, split);
      end if;
    end for;
    "degree of Kinf", Degree(Kinf);

    Kinfx:=RationalFunctionField(Kinf);
    Kinfxy:=PolynomialRing(Kinfx);
    FFKinf:=FunctionField(Kinfxy!Q); // function field of curve over Kinf

    time infplacesKinf:=InfinitePlaces(FFKinf); // places at infinity all of degree 1, will be denoted by P
  until &and[IsOne(Degree(P)) : P in infplacesKinf];
  return AbsoluteDegree(Kinf);
end function;

K<u> := CyclotomicField(3);
Kx<x> := PolynomialRing(K);
Kxy<y> := PolynomialRing(Kx);



//infdeg(L[4]);
